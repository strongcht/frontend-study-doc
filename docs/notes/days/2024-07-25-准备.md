---
layout: doc
---

## 2024 å¹´ 7 æœˆ 25 æ—¥

## 1.å¦‚æœä½ è¦è¯»å–ä¸€ä¸ªç‰¹åˆ«å¤§çš„æ–‡ä»¶åº”è¯¥å¦‚ä½•åš?
ä½¿ç”¨`fs.createReadStream`ä»£æ›¿`fs.readFileSync`

[å‚è€ƒåœ°å€](https://segmentfault.com/a/1190000045090539)
[å‚è€ƒåœ°å€](https://segmentfault.com/a/1190000041489765)

## 2. é˜²æŠ–å’ŒèŠ‚æµ

```js
// é˜²æŠ–ï¼šå°±æ˜¯æŒ‡è§¦å‘äº‹ä»¶å n ç§’åæ‰æ‰§è¡Œå‡½æ•°ï¼Œå¦‚æœåœ¨ n ç§’å†…åˆè§¦å‘äº†äº‹ä»¶ï¼Œåˆ™ä¼šé‡æ–°è®¡ç®—å‡½æ•°æ‰§è¡Œæ—¶é—´ã€‚
function debounce(func, wait) {
    let timer = null;
    return function() {
        const context = this;
        const args = [...arguments];
        if(timer) {
            clearTimeout(timer);
        }
        timer = setTimeout(() => {
            func.apply(context, args);
        }, wait)
    }
}

// ç«‹å³æ‰§è¡Œ
function debunce(func, wait, immediate = false) {
    let timer = null;
    return function() {
        const context = this;
        const args = [...arguments];
        if(timer) {
            clearTimeout(timer);
        }
        if(immediate) {
            const callNow = !timer;
            timer = setTimeout(() => {
                timer = null;
            }, wait);
            if(callNow) func.apply(context, args);
        } else {
            timer = setTimeout(() => {
                func.apply(context, args);
            }, wait)
        }
    }
}

// èŠ‚æµ:å°±æ˜¯æŒ‡è¿ç»­è§¦å‘äº‹ä»¶ä½†æ˜¯åœ¨ n ç§’ä¸­åªæ‰§è¡Œä¸€æ¬¡å‡½æ•°ã€‚
function throttle(func, wait) {
    let timer = null;
    return function() {
        const context = this;
        let args = [...arguments];
        if(!timer) {
            timer = setTimeout(() => {
                timer = null;
                func.apply(context, args);
            }, wait)
        }
    }
}
```

## 3. åƒåˆ†ä½æ ¼å¼åŒ–

```js
// å…ˆåˆ¤æ–­æ­£è´Ÿå’Œå°æ•°éƒ¨åˆ†
function format(number) {
    let isNeg = false;
    let isDecimal = false;
    let interArr = [];
    let decimalArr = [];
    if(number < 0) {
        isNeg = true;
        number = Math.abs(number)
    }
    number = number.toString();
    if(number.indexOf('.') > -1) {
        isDecimal = true;
    }
    interArr = [...number.split('.')[0]];
    decimalArr = number.split('.')[1];
    let flag = 1;
    let len = interArr.length;
    for(let i = len - 1; i >= 0; i--) {
        if(flag % 3 === 0 && i !== 0) {
            interArr.splice(i, 0, ',');
        }
        flag++;
    }
    if(isDecimal) {
        interArr.push('.');
        interArr.push(decimalArr);
    }
    return (isNeg ? '-' : '') + interArr.join('')
}
```

## 4.å‰kä¸ªæœ€å¤§å€¼
```js
// æ–¹æ³•1ï¼šæ’åº
function findKthLargest(nums, k) {
    nums.sort((a, b) => b - a);
    return nums[k - 1];
}

// æ–¹æ³•äºŒï¼š éƒ¨åˆ†å†’æ³¡

function findKthLargest(nums, k) {
    for(let i = 0; i < k; i++) {
        for(let j = 0; j < nums.length - 1 - i; j++) {
            if(nums[j] > nums[j + 1]) {
                [nums[j], nums[j + 1]]=[nums[j + 1], nums[j]]
            }
        }
    }
    return nums[nums.length - k];
}

// æ–¹æ³•ä¸‰ï¼š å°é¡¶å †

function findKthLargest(nums, k) {
    // åˆå§‹åŒ–å°é¡¶å †
    let minHeap = new MinHeap();
    // å‰kä¸ªå…ƒç´ å…¥å †
    for(let i = 0; i < k; i++) {
        minHeap.push(nums[i]);
    }
    // ä»k + 1ä¸ªå…ƒç´ å¼€å§‹ å¦‚æœå½“å‰å…ƒç´ å¤§äºå¯¹é¡¶å…ƒç´  åˆ™ åˆ é™¤å †é¡¶å…ƒç´ ï¼Œåœ¨æ·»åŠ è¯¥å…ƒç´ 
    for(let i = k; i < nums.length; i++) {
        if(nums[i] > minHeap.top()){
            minHeap.push(nums[i]);
            if(minHeap.size() > k) {
                minHeap.pop();
            }
        }
    }
    return minHeap.top();
}

class MinHeap {
    constructor() {
        this.heap = [];
    }

    getParentIndex(i) {
        // return i - 1 >> 1;
        return Math.floor((i - 1) / 2);
    }

    getLeftIndex(i) {
        return 2 * i + 1;
    }

    getRightIndex(i) {
        return 2 * + 2;
    }

    top() {
        return this.heap[0];
    }

    swap(i1, i2) {
        const temp = this.heap[i1];
        this.heap[i1] = this.heap[i2];
        this.heap[i2] = temp;
    }

    size() {
        return this.heap.length;
    }

    push(val) {
        this.heap.push(val);
        this.shifUp(this.heap.length - 1);
    }

    // ä¸Šç§»
    shifUp(index) {
        if (index === 0) { return }
        const parentIndex = this.getParentIndex(index);
        if(this.heap[parentIndex] > this.heap[index]) {
            this.swap(parentIndex, index);
            this.shifUp(parentIndex);
        }
    }

    pop() {
        this.heap[0] = this.heap.pop();
        this.shifDown(0);
    }

    // ä¸‹ç§»
    shifDown(index) {
        const lastIndex = this.size() - 1;
        while (true) {
            // å·¦å³ä¸è¶Šç•Œï¼Œå–å·¦å³ä¸­æœ€å°çš„è¿›è¡Œäº¤æ¢
            const leftIndex = this.getLeftIndex(index);
            const rightIndex = this.getRightIndex(index);
            let findIndex = index;
            if (leftIndex <= lastIndex && this.heap[leftIndex] < this.heap[findIndex]) {
                findIndex = leftIndex;
            }

            if (rightIndex <= lastIndex && this.heap[rightIndex] < this.heap[findIndex]) {
                findIndex = rightIndex;
            }

            if(index !== findIndex) {
                this.swap(findIndex, index);
                index = findIndex;
            } else {
                break;
            }
        }
        // ä¼šè¶…æ—¶
        // const left = this.getLeftIndex(index);
        // const right = this.getRightIndex(index);

        // if(this.heap[index] > this.heap[left]) {
        //     this.swap(index, left);
        //     this.shifDown(left);
        // }

        // if(this.heap[index] > this.heap[right]) {
        //     this.swap(index, right);
        //     this.shifDown(right);
        // }
    }
}
```

## 5.æœ€å¤§å­åºå’Œ

```js

// åªè¾“å‡ºæœ€å¤§å­åºå’Œ
function maxSubArray(nums) {
    let pre = nums[0];
    let res = nums[0];

    for(let i = 1; i < nums.length; i++) {
        pre = Math.max(pre + nums[i], nums[i]);
        res = Math.max(res, pre);
    }

    return res;
}

console.log(maxSubArray([5,4,-1,7,8]));
console.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4]));

// è¾“å‡ºæœ€å¤§å­åºå’Œçš„å­åº

function maxSubArray1(nums) {
    let pre = nums[0];
    let res = nums[0];
    let l = 0, r = 0; // å·¦å³æŒ‡é’ˆè®°å½•å­åº
    let resRange = [l, r];

    
    for(let i = 1; i < nums.length; i++) {
        if(pre + nums[i] > nums[i]) {
            r++;
            pre = pre + nums[i];
        } else {
            pre = nums[i];
            l = r = i;
        }

        if(res < pre) {
            res = pre;
            resRange = [l, r];
        }
    }

    return `å’Œ${res}: å­åºï¼š${nums.slice(resRange[0], resRange[1] + 1)}`
}

console.log(maxSubArray1([5,4,-1,7,8]));
console.log(maxSubArray1([-2,1,-3,4,-1,2,1,-5,4]));
```
## 6.æœ€é•¿å…¬å…±å­ä¸²å’Œæœ€é•¿å…¬å…±å­åºåˆ—

```js
// å­åºåˆ—acdï¼ˆå¯ä¸è¿ç»­ï¼‰ å­ä¸²ad(å¿…é¡»è¿ç»­)

// æœ€é•¿å…¬å…±å­åºåˆ—
// dp[i][j] 
// 1. s[i] == s[j] æ—¶, dp[i][j] = dp[i - 1][j - 1] + 1;
// 2. s[i] != s[j] æ—¶, dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
var longestCommonSubsequence = function(s1, s2) {
    // dp[i][j] ä»¥s1 ç¬¬iç»“å°¾çš„å­ä¸²å’Œ s2ç¬¬jä¸ªç»“å°¾çš„å…¬å…±å­ä¸²é•¿åº¦
    const dp = Array.from(new Array(s1.length + 1), () => new Array(s2.length + 1).fill(0));
    const c = Array.from(new Array(s1.length + 1), () => new Array(s2.length + 1).fill(0));
    for(let i = 1; i <= s1.length; i++) {
        const chart1 = s1[i - 1];
        for(let j = 1; j <= s2.length; j++) {
            const chart2 = s2[i - 1];
            if(chart1 == chart2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else if(dp[i - 1][j] > dp[i][j - 1]) {
                dp[i][j] = dp[i - 1][j];
                c[i][j] = 1;
            } else {
                dp[i][j] =  dp[i][j - 1];
                c[i][j] = -1;
            }
        }
    }

    let m = s1.length, n = s2.length, res = [];
    while(m != 0 && n != 0) {
        if(c[m][n] == 0) {
            res.push(s1[n])
            m--;
            n--;
        } else if(c[m][n] == -1) {
            n--;
        } else {
            m--;
        }
    }

    return `å…¬å…±å­åºåˆ—ï¼š ${res.join('')}, é•¿åº¦ä¸ºï¼š ${dp[s1.length][s2.length]}`
};

console.log(longestCommonSubsequence('abcadf', 'acdad'));
// æœ€é•¿å…¬å…±å­ä¸² 'abcadf', 'acdad'
var longestCommonSubstring = function(s1, s2) {
    // å–s1å’Œs2ä¸­çŸ­çš„ä½œä¸ºs1
    if(s1.length > s2.length) {
        const temp = s1;
        s1 = s2;
        s2 = temp;
    }
    // dp[i][j] ä»¥s1 ç¬¬iç»“å°¾çš„å­ä¸²å’Œ s2ç¬¬jä¸ªç»“å°¾çš„å…¬å…±å­ä¸²é•¿åº¦
    const dp = Array.from(new Array(s1.length), () => new Array(s2.length).fill(0));
    let max = 0, start = 0;
    if(s1[0] == s2[0]) {
        dp[0][0] = 1;
    }
    
    for(let i = 1; i < s1.length; i++) {
        for(let j = 1; j < s2.length; j++) {
            if(s1[i] == s2[j]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
            if(dp[i][j] > max) {
                max = dp[i][j];
                start = i + 1 - max;
            }
        }
    }

    return s1.substr(start, max);
};
console.log(longestCommonSubstring('abcadf', 'acdad'));

```

## 7. å­ä¸²åŒ¹é…

```js
function findSubstring(s, t) {
    for(let i = 0; i < s.length; i++) {
        let l = 0;
        while(l < t.length) {
            if(s[i + l] == t[l]) {
                l++
            } else {
                break;
            }
        }
        if(l == t.length) return i;
    }
    retrun -1;
}
console.log(findSubstring('ababcabcacbab', 'abcac'));

```

## 8. æ— é‡å¤æœ€é•¿å­ä¸²

```js
var lengthOfLongestSubstring = function(s) {
    // æ»‘åŠ¨çª—å£
    const set = new Set();
    let r = 0, max = -1, res = '';
    for(let i = 0; i < s.length; i++) {
        if(i !== 0) {
            set.delete(s[i - 1]);
        }
        
        while(r < s.length && !set.has(s[r])) {
            set.add(s[r]);
            r++;
        }
        if(max < (r - i)) {
            max = r - i;
            res = s.substr(i, max);
        }  
    }
    return `å…¬å…±å­åºæ— é‡å¤æœ€é•¿å­ä¸²ï¼š ${res}, é•¿åº¦ä¸ºï¼š ${max}`;
};

console.log(lengthOfLongestSubstring("abcabcbb"));
```

## 9.æ•°åˆ— ğ‘çš„æ‰€æœ‰åŒºé—´ä¸­ï¼ŒX å€¼æœ€å¤§çš„é‚£ä¸ªåŒºé—´ X = min * sum

```js
// åˆ†åˆ«è®¡ç®—ä»¥a[i] ä¸ºæœ€å°å€¼çš„åŒºé—´çš„Xå€¼ï¼Œå–æœ€å¤§

function maxValue(a) {
    const n = a.length;
    const left = new Array(n).fill(-1);
    const right = new Array(n).fill(n);
    let stack = [];

    // æ‰¾å‡ºiå·¦ä¾§çš„æœ€å°å€¼
    for(let i = 0; i < n; i++) {
        while(stack.length && stack[stack.length - 1] >= a[i]) {
            stack.pop();
        }
        if(stack.length) {
            left[i] = stack[stack.length - 1];
        }
        stack.push(a[i]);
    }
    stack = [];
    // iå³ä¾§æ¯”a[i]å°çš„å€¼
    for(let i = n - 1; i >=0; i--) {
        while(stack.length && stack[stack.length - 1] >= a[i]) {
            stack.pop();
        }
        if(stack.length) {
            right[i] = stack[stack.length - 1];
        }
        stack.push(a[i]);
    }

    let max = 0, maxRange = [0, 0];
    for(let i = 0; i < n; i++) {
        let sum = 0;
        for(let j = left[i] + 1; j < right[i]; j++) {
            sum += a[j];
        }
        const xValue = a[i] * sum;
        if(xValue > max) {
            max = xValue;
            maxRange = [left[i] + 1, right[i]];
        }
    }
    return {max, interval: a.slice(maxRange[0], maxRange[1])}
}

const a = [3,1,6,4,5,2];
const result = maxValue(a);
console.log(`Xå€¼æœ€å¤§çš„åŒºé—´ä¸º ${result.interval}  X = ${result.max}`);
```
## 10.ä¸­åºéå†
> å·¦æ ¹å³
```js
// é€’å½’
var inorderTraversal = function(root) {
    const res = [];
    const inorder = (root) => {
        if(root == null) return;
        inorder(root.left);
        res.push(root.val);
        inorder(root.right);
    }
    inorder(res);
    return res;
};

// stack
var inorderTraversal = function(root) {
    const stack = [];
    const res = [];

    while(root) {
        stack.push(root);
        root = root.left;
    }
    while(stack.length) {
        let node = stack.pop();
        res.push(node.val);
        node = node.right;
        while(node) {
            stack.push(node);
            node = node.left;
        }
    }
    return res;
}
```

## 11. äºŒå‰æœç´¢æ ‘
```js
var isValidBST = function(root) {
    const stack = [];
    let front = -Infinity;

    while(root) {
        stack.push(root);
        root = root.left;
    }
    
    while(stack.length) {
        let node = stack.pop();
        if(node.val <= front) {
            return false;
        }
        front = node.val;
        while(node) {
            stack.push(node);
            node = node.right;
        }
    }
    return true;
}
```

## 12. äºŒå‰æ ‘çš„å±‚åºéå†

```js
var levelOrder = function(root) {
    // é˜Ÿåˆ—
    const queue = [];
    const res = [];

    if(root == null) return res;
    queue.push(root);

    while(queue.length) {
        const levelRes = [];
        const queueLength = queue.length;
        for(let i = 0; i < queueLength; i++) {
            const node = queue.shift();
            levelRes.push(node.val);
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        res.push(levelRes);
    }

    return res;
};
```

```js
var zigzagLevelOrder = function(root) {
    // é˜Ÿåˆ—
    const queue = [];
    const res = [];
    let isEven = true;

    if(root == null) return res;
    queue.push(root);

    while(queue.length) {
        const levelRes = [];
        const queueLength = queue.length;
        for(let i = 0; i < queueLength; i++) {
            const node = queue.shift();
            if(isEven) {
                levelRes.push(node.val);
            } else {
                levelRes.unshift(node.val);
            }
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        isEven = !isEven;
        res.push(levelRes);
    }

    return res;
};
```

```js
var maxDepth = function(root) {
    // const res = [];
    // const dfs = (root, depth) => {
    //     if(root == null) {
    //         res.push(depth);
    //         return;
    //     }
    //     dfs(root.left, depth + 1);
    //     dfs(root.right, depth + 1);
    // }
    // return Math.max(...res);

    // å±‚åºéå†è®°å½•æœ‰å¤šå°‘å±‚
    if(root == null) return 0;
    const queue = [root];
    let depth = 1;
    while(queue.length) {
        const length = queue.length;
        for(let i = 0; i < length; i++) {
            const node = queue.shift();
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        if(queue.length) {
            depth++;
        }
    }
    return depth;
};
```
```js
function TreeNode(val, left, right) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
}
var buildTree = function(preorder, inorder) {
    const n = preorder.length;
    if(n == 0) return null;
    const leftSize = inorder.indexOf(preorder[0]);
    const left = buildTree(preorder.slice(1, leftSize + 1), inorder.slice(0, leftSize));
    const right = buildTree(preorder.slice(leftSize + 1), inorder.slice(leftSize + 1));
    return new TreeNode(preorder[0], left, right);
};
```

```js

// nums = [7, 1, 5, 3, 6, 4];
// ç¬¬iå¤©äº¤æ˜“å®Œæˆæ‰‹é‡Œæ²¡æœ‰è‚¡ç¥¨çš„åˆ©æ¶¦ï¼š dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + nums[i])
// ç¬¬iå¤©äº¤æ˜“å®Œæˆæ‰‹é‡Œæœ‰è‚¡ç¥¨çš„åˆ©æ¶¦ï¼š dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - nums[i])
function time(nums) {
    const n = nums.length;
    const dp = Array.from(new Array(n), () => new Array(2).fill(0));
    dp[0][1] = -nums[0];

    for(let i = 1; i < n; i++) {
        dp[i][0] =  Math.max(dp[i - 1][0], dp[i - 1][1] + nums[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - nums[i])
    }

    return dp[n - 1][0];
}

```